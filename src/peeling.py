#/usr/bin/env python3

"""
Module gethering all functions linked both to the peeling process itself and
generation of the PU found
"""

import os
import subprocess as sub


global a_la_fac
a_la_fac = False

def peeling(peeled_pdb_path, peeled_pdb_id):
    """
    """
    if a_la_fac:
        cmdLine_peel = ("bin/peeling11_4.1 -pdb " + peeled_pdb_path +
                        " -dssp data/" + peeled_pdb_id + ".dss"
                        " -R2 98 -ss2 8 -lspu 20 -mspu 0 -d0 6.0 -delta 1.5"
                        " -oss 0 -p 0 -cp 0 -npu 16")
        # The split function of the shlex module is used to generate a list of args:
        # os.system(cmd_line)
        #out, err = sub.Popen(shx.split(cmd_line), stdout=sub.PIPE).communicate()
        # outPeel_1 = sub.Popen(cmdLine_peel.split(), stdout=sub.PIPE).communicate()[0]
        # lines_peel = outPeel_1.decode().split('\n')

    else:
        cmdLine_peel = ("bin/peel32 " + peeled_pdb_path + " data/" +
                        peeled_pdb_id + ".dss 98 8 20 0 6.0 1.5 0 0 0")
        # with open("data/" + peeled_pdb_id + '_peeled.txt', 'r') as outPeel_1:
        #     content_peel = outPeel_1.read()
        #     print(content_peel)
        #     lines_peel = content_peel.split('\n')

    print("Peeling in progress...")
    outPeel_sub = sub.Popen(cmdLine_peel.split(),
                          stdout=sub.PIPE).communicate()[0]
    # print(outPeel_sub.decode())
    outPeel_w_dies = outPeel_sub.decode().split('\n')

    # Remove files generated by peel32:
    if not a_la_fac:
        os.remove("file_ca_coo.pdb")
        os.remove("file_proba_contact.mat")

    print("Peeling done!\n")
    return [line for line in outPeel_w_dies if line and line[0] != '#']


def peeled_to_dict(line):
    """
    Take a line from the peeling output and return a dictionary, where each key
    is the number of the PU (so starting at 1), with the value being the bounds
    of the considered PU

    Args:
        line: A line (str) from the output of the peeling program

    Returns:
        A dict with {PU_number:[inf_bound, sup_bound]}
    """
    all_bounds = [ int(elem) for elem in line.split()[5:] ]
    nb_tot_PU = len(all_bounds)/2
    i, nb_current_PU = 0, 1
    dict_PU = {}

    while nb_current_PU <= nb_tot_PU:
        dict_PU[nb_current_PU] = all_bounds[i:i+2]
        i += 2
        nb_current_PU += 1

    return dict_PU


def generate_PU_pdbs(dict_PU, level_cut, dict_coord_peeled, peeled_pdb_name):
    """
    Generate different pdb file, associated to each PU, based to the boundaries
    given as output of the peeling program

    Args:
        dict_PU: Dict containing the boundaries of each PU at a given level
        level_cut: The current level considered (int)
        dict_coord_peeled: Coordinates of the peeled pdb (dict)
        peeled_pdb_name: Name (str) of the PDB that have been peeled
    """
    nb_PU = len(dict_PU)

    for i in range(1, nb_PU+1):
        out_file = "results/" + peeled_pdb_name + "_PU_" + str(level_cut)
        with open(out_file + '_' + str(i) + '.pdb', 'w') as out_PU:
            inf_bound, sup_bound = dict_PU[i]

            for resID in range(inf_bound, sup_bound+1):
                out_PU.write(dict_coord_peeled[resID][1])
